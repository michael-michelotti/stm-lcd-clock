/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "string.h"
#include <stdint.h>
#include <stddef.h>
#include "stdio.h"

#include "globals.h"
#include "stm32f407xx.h"
#include "ds3231_rtc_driver.h"
#include "lcd1602a_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// DEFINE the global state variables which were initially DECLARED in globals.h
// Any of the global state variables can be accessed from separate modules by including globals.h
// Display strings for LCD (maximum size of 16 bytes), initiated with all null characters
char global_time_str[16] = { '\0' };
char global_date_str[16] = { '\0' };

I2C_Handle_t global_i2c_handle = { '\0' };
GPIO_Handle_t global_gpio_handle = { '\0' };

uint8_t rx_buffer[255];
uint8_t tx_buffer[255];
uint8_t tx_buffer_pos = 0;
uint8_t rx_buffer_pos = 0;

void init_global_state()
{
	// Initialize global LCD display strings with blank date and time
	char *default_time = "00:00:00";
	char *default_date = "00/00/0000";
	strncpy(global_time_str, default_time, strlen(default_time));
	strncpy(global_date_str, default_date, strlen(default_date));

	I2C_Config_t init_config = { I2C_SPEED_SM, 0x62, 1, I2C_FM_DUTY_2 };
	global_i2c_handle.p_i2c_x = I2C2;
	global_i2c_handle.i2c_config = init_config;
	global_i2c_handle.p_tx_buffer = tx_buffer;
	global_i2c_handle.p_rx_buffer = rx_buffer;
	global_i2c_handle.tx_len = 0;
	global_i2c_handle.rx_len = 0;
	global_i2c_handle.tx_rx_state = 0;
	global_i2c_handle.slave_addr = DS3231_SLAVE_ADDR;
	global_i2c_handle.rx_size = 0;
	global_i2c_handle.sr = 0;



	GPIO_Pin_Config_t toggle = { 0, GPIO_MODE_OUT, GPIO_SPEED_HIGH, GPIO_PUPD_NONE, GPIO_OUT_PP, 0 };
	global_gpio_handle.gpio_pin_config = toggle;
	global_gpio_handle.p_gpio_x = GPIOE;
	GPIO_Init(&global_gpio_handle);
}

int main(void)
{
	// initialize global state variables
	init_global_state();

	// PB10 = SCL, PB11 = SDA
	GPIO_Pin_Config_t pb10 = { 10, GPIO_MODE_ALT, GPIO_SPEED_HIGH, GPIO_PUPD_NONE, GPIO_OUT_OD, 4 };
	GPIO_Handle_t scl_handle = { GPIOB, pb10 };
	GPIO_Init(&scl_handle);

	GPIO_Pin_Config_t pb11 = { 11, GPIO_MODE_ALT, GPIO_SPEED_HIGH, GPIO_PUPD_NONE, GPIO_OUT_OD, 4 };
	GPIO_Handle_t sda_handle = { GPIOB, pb11 };
	GPIO_Init(&sda_handle);



	I2C_Init(&global_i2c_handle, I2C_IT_EN);
	//DS3231_Set_Seconds(&global_i2c_handle, 35, DS3231_BLOCKING_CALL);
	uint8_t secs = DS3231_Get_Seconds(&global_i2c_handle);

	/*
	// configure I2C SDA and SCL pins
	I2C_Config_t i2c2_conf = { I2C_SPEED_SM, 0x62, I2C_ACK_EN, I2C_FM_DUTY_2 };
	I2C_Handle_t i2c2_handle = { I2C2, i2c2_conf, 0, 0, 0, 0, 0, DS3231_SLAVE_ADDR, 0, 0 };
	I2C_Init(&i2c2_handle);

	DS3231_Hours_t hrs = { DS3231_12_HOUR, DS3231_PM, 9 };
	DS3231_Time_t time = { 0, 47, hrs };

	DS3231_Datetime_t dt = { time, date };
	// DS3231_Set_Full_Datetime(&i2c2_handle, dt);
	DS3231_Datetime_t datetime = DS3231_Get_Full_Datetime(&i2c2_handle);

	LCD_Initialize();

	// LCD_Display_Str(date_display_string);

	LCD_Update_Date_And_Time(datetime);

	LCD_Power_Switch(OFF);
	*/

	for(;;)
	{
		//GPIO_Write_To_Output_Pin(global_gpio_handle.p_gpio_x, global_gpio_handle.gpio_pin_config.gpio_pin_num, HIGH);
		//GPIO_Write_To_Output_Pin(global_gpio_handle.p_gpio_x, global_gpio_handle.gpio_pin_config.gpio_pin_num, LOW);
	}
}

void I2C2_EV_IRQHandler(void)
{
	// bottom byte of the SR1 register indicate which event we are handling
	uint8_t event_to_handle = (global_i2c_handle.p_i2c_x->SR1 & 0xFF );
	uint8_t tx_rx_state = global_i2c_handle.task_queue[global_i2c_handle.current_task].tx_or_rx;

	// Handle EV5 - SB is set
	if (GET_BIT(&global_i2c_handle.p_i2c_x->SR1, I2C_SR1_SB_MASK))
	{
		I2C_Handle_SB(tx_rx_state);
		return;
	}
	// Handle EV6 - ADDR is set
	else if (GET_BIT(&global_i2c_handle.p_i2c_x->SR1, I2C_SR1_ADDR_MASK))
	{
		I2C_Handle_ADDR();
		return;
	}
	// Handle EV8_1, EV8_2 and EV8 - both shift register and DR empty
	else if (GET_BIT(&global_i2c_handle.p_i2c_x->SR1, I2C_SR1_TXE_MASK))
	{
		// if both TXE and BTF high, then both SR and DR are empty
		// does it matter? just load DR either way
		I2C_Handle_TXE();
		return;
	}


}
