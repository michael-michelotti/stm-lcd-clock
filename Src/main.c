/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "globals.h"
#include "stm32f407xx.h"
#include "ds3231_rtc_driver.h"
#include "lcd1602a_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// DEFINE the global state variables which were initially DECLARED in globals.h
// Any of the global state variables can be accessed from separate modules by including globals.h
// Display strings for LCD (maximum size of 16 bytes), initiated with all null characters
char global_time_str[16] = { '\0' };
char global_date_str[16] = { '\0' };

I2C_Handle_t global_i2c_handle = { '\0' };

uint8_t rx_buffer[256];
uint8_t tx_buffer[256];

void init_global_state()
{
	// Initialize global LCD display strings with blank date and time
	char *default_time = "00:00:00";
	char *default_date = "00/00/0000";
	strncpy(global_time_str, default_time, strlen(default_time));
	strncpy(global_date_str, default_date, strlen(default_date));

	I2C_Config_t init_config = { I2C_SPEED_SM, 0x62, 1, I2C_FM_DUTY_2 };
	global_i2c_handle.p_i2c_x = I2C2;
	global_i2c_handle.i2c_config = init_config;
	global_i2c_handle.p_tx_buffer = tx_buffer;
	global_i2c_handle.p_rx_buffer = rx_buffer;
	global_i2c_handle.tx_len = 0;
	global_i2c_handle.rx_len = 0;
	global_i2c_handle.tx_rx_state = 0;
	global_i2c_handle.dev_addr = DS3231_SLAVE_ADDR;
	global_i2c_handle.rx_size = 0;
	global_i2c_handle.sr = 0;
}

int main(void)
{
	// initialize global state variables
	init_global_state();

	// PB10 = SCL, PB11 = SDA
	GPIO_Pin_Config_t pb10 = { 10, GPIO_MODE_ALT, GPIO_SPEED_HIGH, GPIO_PUPD_NONE, GPIO_OUT_OD, 4 };
	GPIO_Handle_t scl_handle = { GPIOB, pb10 };
	GPIO_Init(&scl_handle);

	GPIO_Pin_Config_t pb11 = { 11, GPIO_MODE_ALT, GPIO_SPEED_HIGH, GPIO_PUPD_NONE, GPIO_OUT_OD, 4 };
	GPIO_Handle_t sda_handle = { GPIOB, pb11 };
	GPIO_Init(&sda_handle);

	// configure I2C SDA and SCL pins
	I2C_Config_t i2c2_conf = { I2C_SPEED_SM, 0x62, I2C_ACK_EN, I2C_FM_DUTY_2 };
	I2C_Handle_t i2c2_handle = { I2C2, i2c2_conf, 0, 0, 0, 0, 0, DS3231_SLAVE_ADDR, 0, 0 };
	I2C_Init(&i2c2_handle);

	DS3231_Hours_t hrs = { DS3231_12_HOUR, DS3231_PM, 9 };
	DS3231_Time_t time = { 0, 47, hrs };
	DS3231_Full_Date_t date = { DS3231_THU, 9, 2, 23 };
	DS3231_Datetime_t dt = { time, date };
	// DS3231_Set_Full_Datetime(&i2c2_handle, dt);
	DS3231_Datetime_t datetime = DS3231_Get_Full_Datetime(&i2c2_handle);

	LCD_Initialize();

	// LCD_Display_Str(date_display_string);

	LCD_Update_Date_And_Time(datetime);

	LCD_Power_Switch(OFF);

	for(;;);
}

void I2C_Handle_EV5(void)
{
	// just need to set the DR equal to the slave address
	I2C_Write_Address_Byte(global_i2c_handle, DS3231_SLAVE_ADDR, I2C_WRITE);
}

void I2C_Handle_EV6(void)
{
	// address has been acknowledged, clear this by reading from SR2
	// read TRA bit to see whether a read or write was acknowledged
	I2C_Check_Status_Flag(global_i2c_handle, I2C_SR2_TRA, I2C_SR2_CHECK);
}

void I2C_Handle_EV8_1(void)
{
	if (global_i2c_handle.tx_len == 0)
	{
		// if i'm out of data to send, need to generate a stop condition
		// once length becomes 0, wait for txe=1 and btf=1, then generate stop condition
		while (!I2C_Check_Status_Flag(global_i2c_handle, I2C_SR1_TXE, I2C_SR1_CHECK));
		while (!I2C_Check_Status_Flag(global_i2c_handle, I2C_SR1_BTF, I2C_SR1_CHECK));
		I2C_Generate_Stop_Condition(global_i2c_handle);
	}

	// DR is empty, shift register may or may not be empty. Either way, write next byte into DR
	global_i2c_handle.p_i2c_x->DR = *global_i2c_handle.p_tx_buffer;
	global_i2c_handle.p_tx_buffer++;
	global_i2c_handle.tx_len--;
}

void I2C2_EV_IRQHandler(void)
{
	// bottom byte of the SR1 register indicate which event we are handling
	uint8_t event_to_handle = (global_i2c_handle.p_i2c_x->SR1 & 0xFF );

	switch (event_to_handle)
	{
	case I2C_EVENT_SB:
		I2C_Handle_EV5();
		break;
	case I2C_EVENT_ADDR:
		I2C_Handle_EV6();
		break;
	case I2C_EVENT_BTF:
		break;
	case I2C_EVENT_ADD10:
		break;
	case I2C_EVENT_STOPF:
		break;
	case I2C_EVENT_RXNE:
		break;
	case I2C_EVENT_TXE:
		I2C_Handle_EV8_1();
		break;
	}
}
